# sources/graph_mappers.py
from model import Tender, Contract, Location, CPV, Document, Entity 
from slugify import slugify


def get_location_id(country, district=None, municipality=None):
    # 1. Start with the country (Required)
    parts = [slugify(country)]
    
    # 2. Add District if it exists
    if district:
        parts.append(slugify(district))
        
    # 3. Add Municipality if it exists
    if municipality:
        parts.append(slugify(municipality))
        
    # 4. Join them with hyphens
    # Result examples: "loc:portugal", "loc:portugal-lisboa", "loc:portugal-lisboa-cascais"
    return f"loc:{'-'.join(parts)}"


def get_document_url(document_id):
    return f"https://www.base.gov.pt/Base4/pt/resultados/?type=doc_documentos&id={document_id}&ext=.pdf"


def serialize_for_neo4j(obj):
    """
    Convert LinkML objects to Neo4j-compatible primitives.
    
    Handles:
    - LinkML enums -> strings
    - Empty dicts/lists -> removed
    - Nested objects -> recursively processed
    """
    from enum import Enum
    from linkml_runtime.utils.enumerations import EnumDefinitionImpl
    
    if isinstance(obj, dict):
        # Remove empty dicts and lists, serialize remaining values
        result = {}
        for k, v in obj.items():
            serialized = serialize_for_neo4j(v)
            # Skip empty containers
            if serialized not in ({}, []):
                result[k] = serialized
        return result
    
    if isinstance(obj, list):
        return [serialize_for_neo4j(item) for item in obj]
    
    # Handle LinkML enums (instances of EnumDefinitionImpl)
    # These are generated by LinkML from schema enums
    if isinstance(obj, EnumDefinitionImpl):
        return str(obj)
    
    # Handle standard Python Enums
    if isinstance(obj, Enum):
        return obj.value
    
    # Primitives (str, int, float, bool, None)
    return obj


def contract_mapper(raw_doc: dict):
    """
    Takes a raw mixed JSON (Tender + Contract fields flat) 
    and returns a graph batch with validated LinkML objects converted to dicts.
    
    Returns:
        {
            'tenders': [dict],
            'contracts': [dict],
            'locations': [dict, ...],
            'documents': [dict, ...],
            'cpvs': [dict, ...],
            'contracted_entities': [dict, ...],  # Winners
            'contestant_entities': [dict, ...],  # Tenderers
            'procuring_entities': [dict, ...]    # Contracting agencies
        }
    """
    
    # 1. CLEANING: Remove CouchDB metadata
    data = {k: v for k, v in raw_doc.items() if not k.startswith('_')}
    
    # Shared ID for both entities
    shared_id = str(data.get('contract_id'))

    # --- STEP A: Build and Validate LOCATIONS ---
    location_objects = []
    seen_location_ids = set()
    if data.get('execution_location'):
        for loc in data['execution_location']:
            location_id = get_location_id(
                loc.get('country'), 
                loc.get('district'), 
                loc.get('municipality')
            )
            
            # Only add if we haven't seen this location ID yet
            if location_id not in seen_location_ids:
                seen_location_ids.add(location_id)
                # Validate Location
                location_obj = Location(
                    id=location_id,
                    country=loc.get('country'),
                    district=loc.get('district'),
                    municipality=loc.get('municipality')
                )
                location_objects.append(location_obj)

    # --- STEP B: Build and Validate DOCUMENTS ---
    document_objects = []
    seen_document_ids = set()
    if data.get('documents'):
        for doc in data['documents']:
            doc_id = doc.get('id')
            if not doc_id:
                continue
            
            # Only add if we haven't seen this document ID yet
            if doc_id not in seen_document_ids:
                seen_document_ids.add(doc_id)
                # Validate Document
                document_obj = Document(
                    id=str(doc_id),
                    document_url=get_document_url(doc_id),
                    document_description=doc.get('description')
                )
                document_objects.append(document_obj)

    # --- STEP C: Build and Validate CPVs ---
    # CPVs come as a list of strings like ["66171000", "72000000"]
    cpv_objects = []
    seen_cpv_ids = set()
    if data.get('cpvs'):
        for cpv_code in data['cpvs']:
            if not cpv_code or cpv_code in seen_cpv_ids:
                continue
            
            seen_cpv_ids.add(cpv_code)
            # Validate CPV - you'd normally look up label and level from your CPV database
            cpv_obj = CPV(
                id=str(cpv_code),
                label=f"CPV {cpv_code}",  # Required field
                level="division"  # TODO: Determine from code structure or lookup
            )
            cpv_objects.append(cpv_obj)

    # --- STEP D: Build and Validate ENTITIES (SEPARATED BY ROLE) ---
    # VATs come as lists of strings like ["502851791", "600086011"]
    
    # Contracted entities (winners)
    contracted_entity_objects = []
    if data.get('contracted_vats'):
        for vat in data['contracted_vats']:
            if not vat:
                continue
            entity_obj = Entity(
                id=vat,

            )
            contracted_entity_objects.append(entity_obj)
    
    # Contestant entities (tenderers)
    contestant_entity_objects = []
    if data.get('contestants_vats'):
        for vat in data['contestants_vats']:
            if not vat:
                continue
            # Skip if already in contracted (avoid duplicates)
            if vat not in data.get('contracted_vats', []):
                entity_obj = Entity(
                    id=vat,
                )
                contestant_entity_objects.append(entity_obj)
    
    # Procuring entities (contracting agencies)
    procuring_entity_objects = []
    if data.get('contracting_agency_vats'):
        for vat in data['contracting_agency_vats']:
            if not vat:
                continue
            entity_obj = Entity(
                id=vat,
            )
            procuring_entity_objects.append(entity_obj)

    # --- STEP E: Build and Validate CONTRACT ---
    contract_data = {
        "id": shared_id,
        "initial_value": data.get('initial_price'),
        "final_value": data.get('final_price'),
        "signing_date": data.get('signing_date'),
        "execution_deadline": data.get('execution_deadline'),
        "contract_type": data.get('contract_type'),
        "executedAtLocation": location_objects,  # Pass Location objects
        "causes_deadline_change": data.get('causes_deadline_change'),
        "causes_price_change": data.get('causes_price_change'),
        "hasClassification": [cpv.id for cpv in cpv_objects],  # Pass CPV IDs
        "hasDocuments": document_objects  # Pass Document objects
    }
    
    # Validate Contract
    contract_obj = Contract(**contract_data)

    # --- STEP F: Build and Validate TENDER ---
    tender_data = {
        "id": shared_id,
        "procedure_type": data.get('procedure_type'),
        "procurement_method": data.get('procurement_method'),
        "publication_date": data.get('publication_date'),
        "close_date": data.get('close_date'),
        "numberOfTenderers": data.get('numberOfTenderers'),
        "environmental_criteria": data.get('environmental_criteria'),
        "centralized_procedure": data.get('centralized_procedure'),
        "awardsContract": shared_id  # Reference to contract ID
    }
    
    # Validate Tender
    tender_obj = Tender(**tender_data)

    # --- STEP G: FLATTEN FOR NEO4J ---
    # Convert validated objects to dicts using __dict__
    final_tender_dict = tender_obj.__dict__.copy()
    final_contract_dict = contract_obj.__dict__.copy()
    
    # Replace nested Location/Document objects with just their IDs
    # (LinkML stores them as dicts keyed by ID when inlined=True)
    if isinstance(final_contract_dict.get('executedAtLocation'), dict):
        final_contract_dict['executedAtLocation'] = list(final_contract_dict['executedAtLocation'].keys())
    elif isinstance(final_contract_dict.get('executedAtLocation'), list):
        final_contract_dict['executedAtLocation'] = [loc.id if hasattr(loc, 'id') else loc for loc in final_contract_dict['executedAtLocation']]
    
    if isinstance(final_contract_dict.get('hasDocuments'), dict):
        final_contract_dict['hasDocuments'] = list(final_contract_dict['hasDocuments'].keys())
    elif isinstance(final_contract_dict.get('hasDocuments'), list):
        final_contract_dict['hasDocuments'] = [doc.id if hasattr(doc, 'id') else doc for doc in final_contract_dict['hasDocuments']]
    
    # --- STEP H: EXTRACT RELATIONSHIPS (Approach 1) ---
    # Remove relationship fields from node dicts and store separately
    # This prevents them from being stored as node properties in Neo4j
    contract_relationships = {
        'executedAtLocation': final_contract_dict.pop('executedAtLocation', []),
        'hasDocuments': final_contract_dict.pop('hasDocuments', []),
        'hasClassification': final_contract_dict.pop('hasClassification', [])
    }
    
    tender_relationships = {
        'awardsContract': final_tender_dict.pop('awardsContract', None)
    }
    
    # Use the already-created object lists (no need to re-extract)
    location_dicts = [loc.__dict__.copy() for loc in location_objects]
    document_dicts = [doc.__dict__.copy() for doc in document_objects]
    cpv_dicts = [cpv.__dict__.copy() for cpv in cpv_objects]
    contracted_entity_dicts = [entity.__dict__.copy() for entity in contracted_entity_objects]
    contestant_entity_dicts = [entity.__dict__.copy() for entity in contestant_entity_objects]
    procuring_entity_dicts = [entity.__dict__.copy() for entity in procuring_entity_objects]
    
    # --- STEP I: SERIALIZE FOR NEO4J ---
    # Apply serialization to all outputs to convert enums and remove empty dicts
    serialized_contract = serialize_for_neo4j(final_contract_dict)
    serialized_tender = serialize_for_neo4j(final_tender_dict)
    
    # Add relationship data back as metadata (not as node properties)
    serialized_contract['_relationships'] = contract_relationships
    serialized_tender['_relationships'] = tender_relationships
    
    return {
        "tenders": [serialized_tender],
        "contracts": [serialized_contract],
        "locations": [serialize_for_neo4j(d) for d in location_dicts],
        "documents": [serialize_for_neo4j(d) for d in document_dicts],
        "cpvs": [serialize_for_neo4j(d) for d in cpv_dicts],
        "contracted_entities": [serialize_for_neo4j(d) for d in contracted_entity_dicts],
        "contestant_entities": [serialize_for_neo4j(d) for d in contestant_entity_dicts],
        "procuring_entities": [serialize_for_neo4j(d) for d in procuring_entity_dicts]
    }